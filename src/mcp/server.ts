// /src/mcp/server.ts
//
// MCP server that exposes:
// - Resources:
//   - openapi://spec  (runtime fetched YAML)
//   - openapi://index (build-generated JSON index)
// - Tools:
//   - list_objects
//   - list_methods
//   - get_object_help
//   - get_method_help
//
// The OpenAPI spec + build-generated index are the source of truth.
// /src/content docs are used only for optional enhancements.

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import {
	CallToolRequestSchema,
	ListResourcesRequestSchema,
	ListToolsRequestSchema,
	ReadResourceRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { API_INDEX, type ApiMethod, type ApiObject } from "@t/md.generated";
import { z } from "zod";
import { fetchOpenApiSpec, getOpenApiIndexJson } from "./resources";
import { getMethodHelp, getObjectHelp, listMethods, listObjects } from "./tools";

function asNonEmptyTuple<T extends string>(arr: readonly T[]): [T, ...T[]] {
	if (arr.length === 0) {
		throw new Error("Expected non-empty array for enum construction.");
	}
	return arr as unknown as [T, ...T[]];
}

/**
 * Builds a Zod schema where:
 * - object is one of ApiObject
 * - method is restricted to the methods of that object
 *
 * This gives you strong typing + runtime validation.
 */
function buildObjectMethodSchema(): z.ZodTypeAny {
	return z
		.object({
			object: z.enum(asNonEmptyTuple(Object.keys(API_INDEX) as ApiObject[])),
			method: z.string(),
		})
		.refine((value) => (API_INDEX[value.object] as readonly string[]).includes(value.method), {
			message: "Invalid method for object",
		});
}

/**
 * Creates and configures the MCP server with all resources and tools.
 */
export function createMcpServer(baseUrl: string): McpServer {
	const mcpServer = new McpServer(
		{ name: "mtd-api-navigator", version: "1.0.0" },
		{
			capabilities: {
				resources: {},
				tools: {},
			},
		},
	);

	const { server } = mcpServer;

	// -------------------------
	// Resources
	// -------------------------
	server.setRequestHandler(ListResourcesRequestSchema, async () => ({
		resources: [
			{
				uri: "openapi://spec",
				name: "OpenAPI Specification",
				description: "The complete OpenAPI specification for the MTD Developer API (YAML).",
				mimeType: "application/x-yaml",
			},
			{
				uri: "openapi://index",
				name: "OpenAPI Index",
				description:
					"Build-generated index used by MCP tools. Generated by scripts/build-mcp.ts from OpenAPI + docs structure.",
				mimeType: "application/json",
			},
		],
	}));

	server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
		const { uri } = request.params;

		if (uri === "openapi://spec") {
			const spec = await fetchOpenApiSpec();
			return {
				contents: [{ uri, mimeType: "application/x-yaml", text: spec }],
			};
		}

		if (uri === "openapi://index") {
			const json = getOpenApiIndexJson();
			return {
				contents: [{ uri, mimeType: "application/json", text: json }],
			};
		}

		throw new Error(`Unknown resource URI: ${uri}`);
	});

	// -------------------------
	// Tools
	// -------------------------
	server.setRequestHandler(ListToolsRequestSchema, async () => ({
		tools: [
			{
				name: "list_objects",
				description: "Lists all available API objects (derived from docs folder structure).",
				inputSchema: { type: "object", properties: {}, required: [] },
			},
			{
				name: "list_methods",
				description: "Lists all available methods for a specific API object.",
				inputSchema: {
					type: "object",
					properties: {
						object: {
							type: "string",
							description: "The API object name",
							enum: Object.keys(API_INDEX),
						},
					},
					required: ["object"],
				},
			},
			{
				name: "get_object_help",
				description:
					"Gets object-level documentation: methods list, object description text, and example object (if present).",
				inputSchema: {
					type: "object",
					properties: {
						object: {
							type: "string",
							description: "The API object name",
							enum: Object.keys(API_INDEX),
						},
					},
					required: ["object"],
				},
			},
			{
				name: "get_method_help",
				description:
					"Gets method details from OpenAPI (path, HTTP method, params, security) and optional doc enhancements.",
				inputSchema: {
					type: "object",
					properties: {
						object: {
							type: "string",
							description: "The API object name",
							enum: Object.keys(API_INDEX),
						},
						method: {
							type: "string",
							description: "The method (operationId) for that object.",
						},
					},
					required: ["object", "method"],
				},
			},
		],
	}));

	const objectSchema = z.object({
		object: z.enum(asNonEmptyTuple(Object.keys(API_INDEX) as ApiObject[])),
	});

	const objectMethodSchema = buildObjectMethodSchema();

	server.setRequestHandler(CallToolRequestSchema, async (request) => {
		const { name, arguments: args } = request.params;

		switch (name) {
			case "list_objects": {
				const objects = listObjects();
				return {
					content: [{ type: "text", text: JSON.stringify(objects, null, 2) }],
				};
			}

			case "list_methods": {
				const parsed = objectSchema.parse(args);
				const methods = listMethods(parsed.object);
				return {
					content: [{ type: "text", text: JSON.stringify(methods, null, 2) }],
				};
			}

			case "get_object_help": {
				const parsed = objectSchema.parse(args);
				const help = getObjectHelp(parsed.object, baseUrl);
				return {
					content: [{ type: "text", text: JSON.stringify(help, null, 2) }],
				};
			}

			case "get_method_help": {
				const parsed = objectMethodSchema.parse(args) as { object: ApiObject; method: string };

				// `parsed.method` is already validated to the correct method union for that object.
				const help = getMethodHelp(parsed.object, parsed.method as ApiMethod<typeof parsed.object>, baseUrl);

				return {
					content: [{ type: "text", text: JSON.stringify(help, null, 2) }],
				};
			}

			default: {
				throw new Error(`Unknown tool: ${name}`);
			}
		}
	});

	return mcpServer;
}
